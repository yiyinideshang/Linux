# 8.1服务器模型

## 8.1.1 C/S模型

## 8.1.2 P2P模型

# 8.2**服务器编程框架**

I/O处理单元、逻辑单元、网络存储单元、请求队列

![服务器编程框架图8-4](D:\Typora\typora_work\Linux高性能服务器编程\服务器编程框架.jpg)

| 模块         | 单个服务器程序             | 服务器机群                   |
| ------------ | -------------------------- | ---------------------------- |
| I/O处理单元  | 处理客户连接、读写网络数据 | 作为接入服务器，实现负载均衡 |
| 逻辑单元     | 业务进程或线程             | 逻辑服务器                   |
| 网络存储单元 | 本地数据库、文件或缓存     | 数据库服务器                 |
| 请求队列     | 各单元之间的通信方式       | 各服务器之间永久TCP连接      |

# 8.3五种I/O模型

==126、127页==

## 阻塞I/O和非阻塞I/O

- **阻塞I/O**：针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统**挂起**，直到等待的事件发生为止。

  客户端通过connect向服务器发起连接是，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段，如果服务器的确认包文段没有立即送到客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。

  在socket的基础API中， 可能被阻塞的系统调用包括：accept、send、recv和connect

- **非阻塞I/O**：针对非阻塞I/O执行的系统调用**总是立即返回**，而不管事件是否已经发生。如果事件没有立即发生，则这些系统调用返回-1，和出错的情况一样。必须根据`errno`来区分这两种情况。

  - 我们只有在事件已经发生的情况下操作非阻塞I/O(读、写等)，才能提高程序的效率
  - 非阻塞I/O通常要和 **其他I/O通知机制**一起使用，比如**I/O复用** 和 **SIGIO信号**

- **I/O复用**是最常用的I/O通知机制。Linux常用的I/O复用函数是 select 、 poll 、 epoll_wait。

  - ==在第九章讨论==
  - I/O复用本身是阻塞的，它们能提高程序效率的原因在于 它们具有同时监视多个I/O事件的能力

- **SIGIO信号**也是可以用来报告I/O事件。在==6.8节中提到过==

  - ==关于信号的使用在第十章讨论==


## 具体I/O模型对比

| I/O模型   | 读写操作和阻塞阶段                                           |
| --------- | ------------------------------------------------------------ |
| 阻塞I/O   | 程序阻塞于读写函数                                           |
| I/O复用   | 程序阻塞于I/O复用系统调用，但是可以同时监听多个I/O事件，对I/O本身的读写操作是非阻塞的 |
| SIGIO信号 | 信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段 |
| 异步I/O   | 内核执行读写操作并触发读写完成事件。程序没有阻塞阶段         |

| 模式                           | 描述                               | 适用场景       |
| ------------------------------ | ---------------------------------- | -------------- |
| **阻塞I/O**                    | 调用后一直等待直到数据就绪         | 简单应用       |
| **非阻塞I/O**                  | 立即返回，需要**轮询**检查状态     | 低并发场景     |
| **I/O复用**select、poll、epoll | 监控多个描述符，任一**就绪**即处理 | 高并发网络服务 |
| **信号驱动I/O**（SIGIO）       | 内核通过信号通知数据就绪           | 较少使用       |
| **异步I/O**                    | 整个操作完成后才通知               | 高性能应用     |

## 同步I/O模型

程序**亲自等待** I/O 操作完成，并且在操作完成之前，程序会被“**卡住**”（阻塞）或需要**不断主动询问**（非阻塞轮询），直到拿到结果才继续向下执行。

**类比：** 你去银行柜台存钱。

1. 你把银行卡和钱递给柜员（发起I/O请求）。
2. **你就在窗口前站着，什么事也不做，专心等着柜员处理**（等待/阻塞状态）。
3. 柜员处理完毕，把回单和卡递给你（I/O操作完成）。
4. 你拿到回单，离开柜台，去做下一件事（继续执行后续代码）。

**同步I/O的两个主要子类型：**

1. **阻塞式I/O（BIO, Blocking I/O）**：
   - 最经典、最简单的模型。
   - 发起 read/write 系统调用后，**线程会被操作系统挂起**，进入休眠状态，直到数据准备好并被拷贝到用户空间缓冲区，线程才被唤醒继续执行。
   - **特点：** 编程简单，但一个线程只能处理一个连接，资源利用率极低。
2. **非阻塞式I/O（NIO, Non-blocking I/O）**：
   - 发起 read/write 系统调用后，**函数立即返回一个错误码（如 EWOULDBLOCK）**，不会阻塞线程。
   - 但是，程序**需要不断地、主动地循环调用 read/write 去询问**：“数据好了吗？”（轮询，Polling）。
   - 一旦某次询问成功，就进行数据拷贝。
   - **特点：** 线程不会休眠，但需要消耗CPU进行忙等待，效率仍然不高。这是同步的，因为程序依然在主动地、一步步地推进这个I/O任务直到完成。

**一句话总结同步I/O：** **程序的进度与I/O操作的进度保持一致**，程序需要停下来处理I/O。I/O操作“按部就班”地成为程序流程中的一个步骤。

## 异步I/O模型

 程序**委托系统**(内核)去做I/O操作，然后**自己立刻返回去执行后面的代码**，不用等待。系统完成整个I/O操作（包括数据准备和拷贝）后，会通过某种方式（如回调函数、信号、事件）主动通知程序。

**类比：** 你把资料交给秘书去银行代办业务。

1. 你把资料给秘书，并告诉他：“办好了打电话告诉我”（发起异步I/O请求，并注册回调函数）。
2. **你不需要在办公室干等，立刻就可以去做其他工作**（立即返回，执行后续逻辑）。
3. 秘书去银行排队办理（内核进行I/O操作）。
4. 秘书办完所有手续，拿到回单（内核完成数据准备和拷贝）。
5. 秘书给你打电话：“事情办好了，结果在这里”（内核通过回调/事件通知程序）。
6. 你接到电话，处理拿到的结果（在回调函数里处理数据）。

**关键点：**

- **“异步”强调的是“通知”**，而不是轮询。
- 程序从发起请求到收到通知的这段时间内，**完全自由**，可以处理其他任务。
- 这是实现高性能、高并发服务的核心模型。

## 核心区别对比表

| 特性           | 同步 I/O                                                  | 异步 I/O                                                     |
| :------------- | :-------------------------------------------------------- | :----------------------------------------------------------- |
| **程序行为**   | 发起请求后，**等待并参与**直到操作完成。                  | 发起请求后，**立即返回**，去做别的事。                       |
| **主动权**     | 程序主动等待/轮询结果。                                   | 程序被内核/系统**通知**结果。                                |
| **编程复杂度** | 相对简单，流程线性。                                      | 相对复杂，逻辑是事件驱动的、非线性的（回调地狱，但可用 Promise/async-await 优化）。 |
| **资源利用**   | 对于阻塞式，线程资源在等待时被浪费。                      | 线程资源利用率极高，一个线程可以处理成千上万的连接。         |
| **性能**       | 适合连接数不多的场景。                                    | 适合高并发、连接数巨大的场景（如聊天服务器、网关）。         |
| **典型 API**   | `read()`, `write()`（阻塞），`select()`, `poll()`（轮询） | Linux: `aio_read()`, `aio_write()`, **`io_uring`** Windows: **IOCP** 高级框架：Node.js, Nginx, Redis |

## 技术流程图解

### 同步阻塞式I/O

```
应用程序线程： [调用read] -> [阻塞等待] -> [数据拷贝] -> [处理数据]
内核：           [等待数据] -> [数据准备] -> [拷贝到用户空间]
```

### 异步I/O

```
应用程序线程： [调用aio_read] -> [立即返回，处理其他逻辑] -> ... -> [收到通知，处理数据]
内核：           [等待数据] -> [数据准备] -> [拷贝到用户空间] -> **发送完成信号**
```

## 实际应用举例

- **同步I/O**：传统的Java Socket（BIO），PHP-FPM，大多数简单的文件读写脚本。
- **异步I/O**：
  - **Node.js**：整个生态系统构建在异步I/O之上。
  - **Nginx**：使用异步非阻塞模型处理海量HTTP连接。
  - **Redis**：单线程依靠异步I/O处理高并发请求。
  - **现代数据库连接池**。
  - **游戏服务器**。

### 总结与常见误区

- **误区：非阻塞I/O就是异步I/O。**
  - **纠正**：不对。非阻塞I/O只是同步I/O的一种。它不“阻塞”线程，但程序仍需**主动轮询**，这依然是同步思维。真正的异步I/O不需要程序主动询问，而是靠“通知”。
- **关键判别方法**：看从发起I/O请求到数据**真正准备好、并已被拷贝到用户缓冲区**这个完整的过程，程序是否需要等待或参与。如果需要，就是同步；如果完全托管出去，就是异步。

简单来说：**同步是“等事情做完”，异步是“事情做好了叫我”**。在高性能网络编程中，异步I/O模型是解决C10K、C100K甚至C10M问题的关键技术基石。

# 8.4两种高效的事件处理模式

- 服务器程序通常需要处理三类事件：
  - I/O事件、
  - 信号、==在第十章讨论==
  - 定时事件==第十一章讨论==
- 两种高效的事件处理模式

Reactor 反应堆

Proactor 前摄器

**同步I/O模型**常用于：实现`Reactor`模式  ----使用同步I/O方式模拟出`Proactor`模式

**异步I/O模型**常用于：实现`Proactor`模式

## 8.4.1 Reator模式（反应器模式）

**"当事件就绪时，通知应用程序进行处理"** - 应用程序负责实际的I/O操作

- 具体I/O操作通过非阻塞I/O来完成---工作线程--逻辑单元
- 具体I/O是否就绪，由I/O多路复用来完成--主线程---I/O处理单元

- ## 工作流程

1. **注册**：应用程序向Reactor注册感兴趣的事件和对应的处理器
2. **监听**：Reactor通过同步事件多路分离器（如select/epoll）等待事件发生
3. **分发**：事件发生后，Reactor将事件分发给相应的处理器
4. **处理**：处理器执行**非阻塞**的I/O操作

## 8.4.2 Proactor模式（前摄器模式）

**"I/O操作完成后，通知应用程序"** - 操作系统/框架负责实际的I/O操作

- 所有I/O操作都交给主线程和内核来处理，工作线程只负责业务逻辑

- ## 工作流程

1. **发起**：应用程序发起异步I/O操作
2. **执行**：操作系统执行实际的I/O操作
3. **通知**：操作完成后，操作系统通知应用程序
4. **处理**：应用程序处理完成的数据

## 8.4.3 使用同步I/O模拟Proactor模式

将同步I/O操作放入独立线程执行，模拟异步效果

- ## 实现要点

1. **线程池**：使用工作线程执行同步I/O操作
2. **任务队列**：存储待执行的I/O任务
3. **完成队列**：存储已完成的I/O操作结果
4. **回调机制**：通过完成处理器回调应用程序
5. **非阻塞调用**：应用程序调用async_read/async_write后立即返回

## 对比总结

| 特性          | Reactor模式      | Proactor模式     | 同步I/O模拟Proactor               |
| :------------ | :--------------- | :--------------- | :-------------------------------- |
| I/O操作执行者 | 应用程序         | 操作系统/框架    | 工作线程                          |
| 通知时机      | I/O就绪时        | I/O完成时        | I/O完成时                         |
| 编程复杂度    | 中等             | 较低             | 较高                              |
| 性能          | 依赖应用程序效率 | 依赖操作系统支持 | 有线程切换开销                    |
| 适用场景      | 高并发连接       | 高吞吐量操作     | 需要异步接口但不支持异步I/O的系统 |

1. **Windows IOCP**：原生的Proactor实现
2. **Linux/Unix**：通常使用Reactor（epoll + 非阻塞I/O）
3. **模拟方案**：当需要统一接口或移植代码时使用
4. **性能考虑**：线程切换和同步开销可能影响性能

通常建议根据**操作系统**特性选**择原生支持的模式**以获得最佳性能。

# 8.5 两种高效的并发模式

## 8.5.1 半同步/半异步模式

这里的“同步”和“异步” 与之前讨论的 I/O模型中的  “同步”和“异步”是不同的概念

- 在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是**就绪事件**还是**完成事件**），以及该由谁完成I/O读写（是应用程序还是内核）
- 在并发模式中，“同步”指的是 程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。 常见的**系统事件**有：**中断**、**信号**

按照同步方式运行的线程 称为 同步线程，按照异步方式运行的线程 称为 异步线程。异步线程的执行效率高，实时性强，是很多嵌入式程序采用的模型，但是编写异步方式执行的程序 相对复杂，难于调试和扩展，而且不适合大量的并发

而同步线程则相反，虽然效率相对较低，实时性较差，但逻辑简单。

对于服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，就应该同时使用 同步线程和异步线程实现，即采用半同步/半异步模式

- 半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4中的逻辑单元
- 异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。异步线程在监听到客户请求后，就将其封装成请求对象并插入请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象

## 8.5.2 领导者/追随者模式

# 8.6 有限状态机

# 8.7提高服务器性能的其他建议

## 8.7.1池

## 8.7.2数据辅助

## 8.7.3上下文切换和锁
