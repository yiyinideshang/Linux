# 扩展与实用建议

## 常用信号调试命令

- `kill -l` 列出所有信号。
- `ps -e` 查看进程 PID。
- `strace` 跟踪系统调用，观察信号处理过程。
  - **`starce`**工具的使用见：`D:\Typora\typora_work\Linux高性能服务器编程\9.IO复用的高级应用1非阻塞connect.md`
- `gdb` 中处理信号的方法（`handle` 命令）。

## 实践练习

- 例如：编写一个程序，使用 `sigaction` 捕获 `SIGUSR1`，并在处理函数中打印发送者 PID；另一个进程用 `kill` 发送信号。
- 使用 `sigpending` 和 `sigsuspend` 实现简单的等待信号机制。

## 指出常见陷阱

- 不能在信号处理函数中调用非异步信号安全函数，否则可能导致死锁或 crash。
- `sigprocmask` 在多线程中的未定义行为，应使用 `pthread_sigmask`。
- 如果信号处理函数中设置了全局变量（如 `flag`），应使用 `volatile sig_atomic_t` 类型保证原子访问。

# 10.1Linux信号概述

## 10.1.1 发送信号

`Linux`下，**一个进程个其他进程发送信号**的`API`是`kill`函数，定义如下:

```c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid,int sig);
```

该函数把信号`sig`发送诶目标进程；

### 	`pid`参数

目标进程由`pid`参数指定，取值及含义如下：

| `pid`参数 | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| `pid>0`   | 信号发送给`PID`为`pid`的进程                                 |
| `pid=0`   | 信号发送给本进程组内的其他进程                               |
| `pid=-1`  | 信号发送给除`init`进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限 |
| `pid<-1`  | 信号发送给组`ID`为`-pid`的进程组中的所有成员                 |

### 	`sig`参数

`Linux`定义的信号值都大于0，如果`sig`的取值为0，则kill函数不发送任何信号，但将`sig`设置为0可以用来检测目标进程或目标进程组是否存在，因为检查工作总是在信号发送之前就执行。不过这种检测方式是不可靠的，一方面因为进程`PID`的回绕，另一方面这种检测方法不是原子性的。

### 	返回值

该函数成功返回0，失败返回-1并设置`errno`，以下是几种可能的`errno`

`kill`出错的情况

| `errno`  | 含义                                     |
| -------- | ---------------------------------------- |
| `EINVAL` | 无效的信号                               |
| `EPERM`  | 该进程没有权限发送信号给任何一个目标进程 |
| `ESRCH`  | 目标进程或者进程组不存在                 |

## 10.1.2 信号处理方式

**目标进程在收到信号后，需要定义一个接受函数来处理之。**信号处理函数的原型如下：

```c
#include <signal.h>
typedef void(*_sighandler_t) (int);
```

信号处理函数 只有一个 **整数参数，用来指定信号类型**。该函数是**可重入**的，在信号处理函数中**严禁调用一些不安全的函数**

除了**用户自定义信号处理函数**之外，`bits/signum.h`头文件中还定义了信号的两种其他处理方式-----

**`SIG_DFL`和`SIG_IGN`**

```c
#include <bits/signum.h>
#define SIG_DFL ((_sighandler_t) 0)
#define SIG_IGN ((_sighandler_t) 1)
```

`SIG_DFL`：表示使用**信号的默认处理方式**。

`SIG_IGN`：表示**忽略目标信号**。

- 信号的默认处理方式有以下几种：
  - 结束进程 `Term`
  - 忽略信号 `Ign`
  - 结束进程并生成核心转储文件`Core`
  - 暂停进程 `Stop`
  - 继续进程 `Cont`

<!--什么是异步信号安全函数-->

<!--常见的安全函数（如 `write`、`signal` 本身、`_exit`）和不安全函数（如 `printf`、`malloc`、`pthread` 函数）。-->



## 10.1.3 Linux信号

`Linux`的可用信号都定义在`bits/signum.h`头文件中，其中包括标准信号和`POSIX`实时信号，以下是`Linux`标准信号

| 信号     | 起源  | 默认行为 | 含义                         |
| -------- | ----- | -------- | ---------------------------- |
| `SIGHUP` | POSIX | Term     | 控制终端挂起                 |
| `SIGINT` | ANSI  | Term     | 键盘输入以中断进程(`ctrl+C`) |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |

### 实时信号

实时信号（`SIGRTMIN` 到 `SIGRTMAX`）的特点：支持排队、可附带数据（通过 `sigqueue`），可以在 `sigaction` 的 `siginfo_t` 中获取。

## 10.1.4 中断系统调用

使用`sigaction`函数，为信号设置`SA_RESTART`标志以自动重启被该信号中断的系统调用。

对于**默认行为是 暂停进程的信号**(如`SIGSTOP`、`SIGTTIN`)，如果没有为他们设置信号处理函数，则它们也可以中断某些系统调用(如`connect`、`epoll`、`epoll_wait`).`POSIX`中没有这种规定，这是`Linux`独有的。

# 10.2 信号函数

## 10.2.1 `signal`系统调用

```c
#include <signal.h>
typedef void (*sighandler_t)(int);//sighandler_t是这样一个类型，void (*)(int)
sighandler_t signal(int sig, sighandler_t _handler);
```

```c
void (*signal(int sig, void (*func)(int)))(int);
```

### 	参数解释

- **`sig`**：整数，指定要操作的信号类型（例如 `SIGINT`、`SIGTERM` 等）。
- **`_handler`**：`sighandler_t` 类型的函数指针，用于指定信号`sig`的处理函数
  - `sighandler_t` 被定义为：`typedef void (*sighandler_t)(int);`
  - 即 `_handler` 指向一个 **参数为 `int`、返回值为 `void` 的函数**（该 `int` 参数会被传入触发信号的编号）。（即指向信号`sig`的处理函数）
  - `_handler` 也可以是两个特殊宏：
    - `SIG_DFL`：默认处理（由系统决定，如终止进程、忽略等）。
    - `SIG_IGN`：忽略该信号。

###  	返回值

函数返回结果： 前一次对该`sig`信号 调用`signal`函数时传入的函数指针，

- **成功**：返回一个 `sighandler_t` 类型的函数指针，指向 **本次调用之前** 为该信号 `sig` 安装的处理函数。(上次调用`signal`的第二个参数)
  - 可能是上一次调用 `signal` 时传入的自定义函数指针。
  - 也可能是 `SIG_DFL` 或 `SIG_IGN`
    - 如果从未对该信号调用过 `signal`，则返回初始默认值 `SIG_DFL` 或 `SIG_IGN`（取决于系统默认行为）。
- **失败**：返回 `SIG_ERR`（也是一个 `sighandler_t` 类型的特殊值），并设置 `errno` 以指示错误。

## 10.2.2 `sigaction`系统调用

`sigaction` 是 UNIX/Linux 系统中用于**检查或更改信号处理动作**的系统调用。它比传统的 `signal` 函数更加强大、可靠，并且是 POSIX 标准推荐使用的信号管理接口。

### 1. 函数原型

```c
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

- **`signum`**：要操作的信号编号（除 `SIGKILL` 和 `SIGSTOP` 外，所有信号均可捕获或忽略）。
- **`act`**：如果非空，指向一个 `struct sigaction` 结构体，用于指定对 `signum` 的新处理方式。
- **`oldact`**：如果非空，用于返回之前对 `signum` 的处理方式（即上一次设置的 `struct sigaction` 内容）。
- **返回值**：成功返回 0；失败返回 -1，并设置 `errno`。

### 2. `struct sigaction` 结构体

```c
struct sigaction {
    union
    {
	void     (*sa_handler)(int);        /* 简单信号处理函数 */
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 带额外信息的处理函数 
    }
    
    sigset_t   sa_mask;                  /* 在处理函数执行期间要阻塞的信号集 */
    int        sa_flags;                  /* 控制信号处理行为的标志 */
    void     (*sa_restorer)(void);       /* 已废弃，不应使用: 通常不关心，设为 NULL 即可*/
};
```

- **`sa_handler` 与 `sa_sigaction`**：二者是互斥的，通过 `sa_flags` 中的 `SA_SIGINFO` 标志来选择使用哪一个。若设置了 **`SA_SIGINFO`**，则使用 `sa_sigaction`；否则使用 `sa_handler`。
  - `sa_handler`：与 `signal` 的处理函数类似，接收一个 int 参数（信号编号），返回 void。
  - `sa_sigaction`：接收三个参数：
    - `int`：信号编号。
    - `siginfo_t *`：指向一个包含信号详细信息的结构体（如发送进程 PID、用户 ID、信号值、伴随数据等）。
    - `void *`：通常指向 `ucontext_t` 结构体，包含信号发生时的上下文信息（可忽略）。
- **`sa_mask`**：指定在调用处理函数期间，除了当前信号自动被屏蔽外，额外要阻塞的信号集。这样可以防止在处理某个信号时，被其他信号中断。当处理函数返回后，原信号屏蔽字会自动恢复。
  - `sa_mask`是**信号集`sigset_t`**(同`_sigset_t`)类型，该类型**指定一组信号**，==关于信号集，见后文==
- **`sa_flags`**：一组位掩码，用于修改信号处理的行为。常用值包括：
  - `SA_RESTART`：使被信号中断的系统调用自动重启（例如 `read`、`write`），从而避免 `EINTR` 错误。
  - `SA_SIGINFO`：使用 `sa_sigaction` 作为处理函数，而非 `sa_handler`。
  - `SA_NOCLDSTOP`：仅在 `signum` 为 `SIGCHLD` 时有效，表示当子进程停止（而不是终止）时不产生 `SIGCHLD` 信号。
  - `SA_RESETHAND`：处理函数执行一次后，将信号动作恢复为默认值（`SIG_DFL`），类似 `signal` 的旧语义。
  - `SA_NODEFER`：在处理函数执行期间，不自动屏蔽当前信号（即允许递归发送该信号）。
  - 其他标志可参考 man 手册。

### 3. 与 `signal` 的比较

| 特性             | `signal`                     | `sigaction`                          |
| :--------------- | :--------------------------- | :----------------------------------- |
| **可移植性**     | 行为因系统而异（SysV/BSD）   | POSIX 标准，行为一致                 |
| **可靠性**       | 可能不支持信号排队、丢失信息 | 支持可靠信号（排队、额外信息）       |
| **信号屏蔽字**   | 无法指定额外阻塞的信号       | 可通过 `sa_mask` 指定                |
| **获取详细信息** | 不能                         | 通过 `SA_SIGINFO` 可获得发送方信息等 |
| **系统调用重启** | 无法控制                     | 可通过 `SA_RESTART` 控制             |
| **一次性处理**   | 有些实现默认一次性           | 可通过 `SA_RESETHAND` 控制           |
| **递归发送控制** | 无法控制                     | 可通过 `SA_NODEFER` 控制             |

简言之，**`sigaction` 是 `signal` 的超集**，提供了精细的控制和更多的功能。

# 10.3 信号集

`Linux`使用**信号集（signal set）**，用于表示一组信号，它是一种数据类型（`sigset_t`）。

信号集函数就是用来操作这种数据类型的工具，常用于设置进程的信号屏蔽字（blocked set）、等待信号集等场景。它们是实现精确信号控制的基础。

## 1. 为什么需要信号集？

- 进程可以**阻塞**某些信号，即暂时不递送它们，直到解除阻塞。
- 进程可能需要**等待**一组信号中的任意一个到达（如 `sigsuspend`、`sigwait`）。
- 信号处理函数执行期间，可以指定额外的信号被阻塞（通过 `sigaction` 的 `sa_mask` 字段）。

所有这些操作都需要一种方式来表示“一组信号”，这就是信号集的作用。

## 2. 信号集数据类型：`sigset_t`

在Linux 系统（特别是 glibc）中的实际内部表示：

```c
#define _SIGSET_NWORDS (1024/(8*sizeof(unsigned long int)))
typedef struct {
    unsigned long int _val[_SIGSET_NWORDS];
} _sigset_t;
```

从以上定义可以知道，`sigset_t`实际上是一个长整型数组，  `_val` 数组是一个位掩码（`bitmask`），每个位代表一个信号。这种定义方式 和 文件描述符 `fd_set`类似 **==`select`系统调用==**

- **应用程序不应该直接操作 `_val` 数组，应使用函数操作。**
- **接口层面，我们把它看作不透明的**——即我们只知道它的名字，而不知道它的内部布局，并且我们应该通过专门的操作函数来使用它。
- 不能直接操作它的内部表示，而必须通过专门的函数来**设置**、**修改**、**删除**和**查询信号集**。

## 10.3.1信号集函数

这些函数的原型都在 `<signal.h>` 中定义，成功时返回 0，失败返回 -1 并设置 `errno`（但通常不会失败，除非传入无效指针）。

```c
#include <signal.h>
int sigemptyset(sigset_t *set);//清空信号集
int sigfillset(sigset_t *set);//填充所有信号
int sigaddset(sigset_t *set, int signum);//将信号signum添加到信号集中
int sigdelset(sigset_t *set, int signum);//将信号signum从信号集中删除
int sigismember(const sigset_t *set, int signum);//测试signnum是否在信号集中
```

- `sigemptyset()`
  - 将信号集 `set` 初始化为**空**（不包含任何信号）。
  - 在使用任何信号集之前，必须先调用 `sigemptyset` 或 `sigfillset` 进行初始化。
- `sigfillset()`
  - 将信号集 `set` 初始化为包含**所有已定义信号**（通常包括所有标准信号，可能不包括实时信号范围以外的值）。

- `sigaddset()`
  - 将信号 `signum` 添加到信号集 `set` 中。
- `sigdelset()`
  - 将信号 `signum` 从信号集 `set` 中移除。
- `sigismember()`
  - 检查 `signum` 是否是 `set` 的成员。
  - 返回值：如果 `signum` 在 `set` 中，返回 **1**；不在则返回 **0**；出错返回 -1。

*这些函数封装了内部细节，确保无论内部实现如何，都能正确操作。例如，在 Linux 上，`sigaddset` 可能会计算出信号编号对应的数组索引和位掩码，然后设置 `_val[索引]` 的对应位。但在应用程序看来，它只是“添加信号”的抽象操作。*

- ## 为什么说`sigset_t`是不透明的

  - **从 API 设计角度**：POSIX 规范将 `sigset_t` 定义为一个**不完整的类型**（可能通过前向声明），但实际实现中通常会给出完整定义，以便编译器分配内存。然而，规范强调应用程序**必须通过函数来操作**，而不能依赖其内部结构。这就是“**不透明数据类型**”的核心含义。
- **从编程实践角度**：优秀的编程习惯是始终使用操作函数，而不是直接访问成员。即使你知道内部结构，直接访问也会带来上面提到的风险和可移植性问题。

## 10.3.2 进程信号掩码

前文提到，可以利用`sigaction`结构体的`sa_mask` 成员来设置进程的信号掩码，此外，下面函数也可以用于设置或查看进程的信号掩码

==`sa_mask` 只是临时掩码，而 `sigprocmask` 设置的是进程的持久掩码。==

### 什么是信号掩码

指定在调用处理函数期间，除了当前信号自动被屏蔽外，**额外要阻塞的信号集**。这样可以防止在处理某个信号时，被其他信号中断。

### 	函数原型及参数解释

```c
#include <signal.h>
int sigprocmask(int _how,_const sigset_t* _set,sigset_t* _oset);
```

- `_set`参数 指定新的信号掩码，它是一个指向信号集`sigset_t`的指针，指定本次调用要操作的具体信号集合。
- `_oset`参数 如果`_oset`不为`NULL`，函数会调用前的旧信号掩码保存其中。如果只关心修改掩码而不需要旧值，可以将其设置为`NULL`。
- 如果 `_set`参数不为`NULL`，则`_how`参数 **指定设置进程信号掩码的方式(指示如何修改信号掩码)**，其值如下表：

| 参数值        | 行为描述                                                     |
| :------------ | :----------------------------------------------------------- |
| `SIG_BLOCK`   | 将 `_set` 指向的信号集添加到当前的阻塞集中（取并集u）。<br />新的进程信号掩码是当前值和`_set`指向的信号集的并集 |
| `SIG_UNBLOCK` | 将 `_set` 指向的信号集从当前的阻塞集中移除。(从当前信号掩码中移除 set 中的信号) |
| `SIG_SETMASK` | 将当前的阻塞集直接设置为 `_set` 指向的信号集。               |

- **如果`_set`参数为`NULL`**，则进程信号掩码不变，忽略`_how`参数，但此时可以**通过`_oset`来返回当前信号掩码的值**

### 	返回值

`sigprocmask` 成功返回0，失败返回-1,并设置`errno`,常见的错误是 `EINVAL`，表示 `how` 参数的值无效。

### 使用示例：

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main() {
    sigset_t newmask, oldmask;

    // 1. 初始化一个信号集，并添加想要阻塞的 SIGINT
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);

    // 2. 阻塞 SIGINT 信号，并保存旧的信号掩码
    if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1) {
        perror("sigprocmask SIG_BLOCK error");
        return 1;
    }
    printf("SIGINT is now blocked. Try pressing Ctrl+C for 5 seconds...\n");

    // 3. 执行关键代码段（例如模拟耗时操作）
    sleep(5);

    // 4. 使用 SIG_SETMASK 恢复原来的信号掩码，从而解除对 SIGINT 的阻塞
    //    此时，如果在阻塞期间收到了 SIGINT，它会被立即递送
    if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1) {// 解除阻塞，挂起的 SIGINT 立即递送
        perror("sigprocmask SIG_SETMASK error");
        return 1;
    }
    printf("Signal mask restored. SIGINT is now unblocked.\n");

    // 5. 再次暂停，以便观察是否有信号被递送
    printf("Pausing for 5 seconds. Try pressing Ctrl+C now...\n");
    sleep(5);

    return 0;
}
```

- 这个代码，在阻塞期间将`SIGINT`(键盘输入中断进程`ctrl+c`)阻塞

  - ## **阻塞期间**：

  ```c
  sigprocmask(SIG_BLOCK, &newmask, &oldmask);   // 阻塞开始
  sleep(5);                                      // 阻塞期间
  sigprocmask(SIG_SETMASK, &oldmask, NULL);     // 阻塞结束，恢复原掩码
  ```

- 如果在阻塞期间收到被阻塞的信号`SIGINT`时，并不会直接**丢失**该信号，而是被内核记录下来，变为**挂起(pending)**状态。也就是说，内核知道这个信号来了，但因为当前进程（或线程）不想立即处理它，所以暂时搁置。

- 如果信号是**标准信号**（如 `SIGINT`），在阻塞期间如果多次收到同一个信号，**通常只会记录一次**（即不会排队），而**实时信号会排队。**
- 在阻塞期间，该信号的处理函数**不会被执行**(当前是默认处理函数，将`Ctrl+C`作为中断进程的标志)，进程也不会被终止（如果是默认终止行为）。

当通过 `sigprocmask(SIG_SETMASK, &oldmask, NULL)` **解除阻塞**后，内核会检查当前是否有**挂起的信号**。如果发现有之前被阻塞的信号（比如你在那 5 秒里按了 `Ctrl+C` 产生的 `SIGINT`），那么内核会在 `sigprocmask` 函数**返回之前**（或返回后马上）将那个挂起的信号**递送给进程**。

“递送”意味着：

- 如果该信号有自定义的处理函数，会立即执行那个函数。
- 如果该信号的处置是默认动作（比如 `SIGINT` 默认终止进程），那么进程会被终止。

所以，在你代码中恢复掩码之后，**如果阻塞期间按过 Ctrl+C**，那么恢复掩码后程序会立即收到 `SIGINT`，很可能在打印 `"Signal mask restored..."` 之前或之后**立即终止**，导致最后的 `sleep(5)` 根本来不及执行。

如果在阻塞期间没按过`Ctrl+C`，在` printf("Pausing for 5 seconds. Try pressing Ctrl+C now...\n");`之后再按`Ctrl+C`，会调用默认处理函数，将`Ctrl+C`作为中断进程的标志，会被执行。

### 阻塞和忽略

（阻塞是暂时不递送，但信号仍然挂起；忽略是递送后丢弃）。

### 下面的代码将更加直观：

````c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void sigint_handler(int sig) {
    write(STDOUT_FILENO, "\nCaught SIGINT!\n", 16);
    //使用write而不是printf,是因为
    //write 是一个系统调用，直接陷入内核，不涉及用户态的复杂缓冲和锁机制，它是异步信号安全的，可以在信号处理函数中安全地使用。
}

int main() {
    struct sigaction sa = { .sa_handler = sigint_handler };
    sigaction(SIGINT, &sa, NULL);

    sigset_t newmask, oldmask;
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);

    sigprocmask(SIG_BLOCK, &newmask, &oldmask);
    printf("SIGINT blocked. You have 5 seconds to press Ctrl+C...\n");
    sleep(5);   // 在这期间按 Ctrl+C，信号被挂起

    printf("Restoring mask...\n");
    sigprocmask(SIG_SETMASK, &oldmask, NULL);   // 解除阻塞，挂起的 SIGINT 立即递送
    // 注意：此处可能不会立即执行下一行，因为信号处理函数会先运行

    printf("Mask restored. Doing another sleep...\n");
    sleep(5);
    return 0;
}
````

```c
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ ./test 
SIGINT blocked. You have 5 seconds to press Ctrl+C...
^C
Restoring mask...

Caught SIGINT!
Mask restored. Doing another sleep...
^C
Caught SIGINT!
```

将`SIGINT`信号自定义了一个处理函数，而不是默认的中断进程了，当收到这个信号时只会	调用 `write` 系统调用向标准输出（文件描述符`STDOUT_FILENO`，即1）写入一串字符，而不是中断进程

当在**阻塞`SIGINT`期间**，按下 `Ctrl+C`，则将这个信号**挂起**，**当结束阻塞后，立即投递给进程**，输出这个信号 处理函数的结果(`Caught SIGINT`!)

当**不阻塞`SIGINT`期间**，也就是`sigprocmask(SIG_SETMASK, &oldmask, NULL);//解除阻塞`之后，按下`Ctrl+C`，则将立即投递给进程，输出这个信号 处理函数的结果(`Caught SIGINT`!)

## 10.3.3 被挂起的信号

   设置进程信号掩码后，**被屏蔽的信号**将不会被进程接收。如果给进程发送被屏蔽的信号，那么操作系统将该信号设置为进程的一个被**挂起**的信号。如果取消对被挂起的信号的屏蔽，则它能立即被进程接收到。

### 函数原型

- **获取进程当前被挂起的信号集**:

```c
#include<signal.h>
int sigpending(sigset_t* set);
```

`set`参数用于保存被挂起的信号集。

进程即使多次收到同一个被挂起的信号，`sigpending`函数也只能反映一次，并且，当再次使用`sigpromark`使该被挂起的信号生效时，该信号的处理函数也只能被触发一次。

### 返回值：

`sigpending`成功返回0，失败返回-1，并设置`errno`。

### 提醒：

要始终清楚地知道进程在每个运行时刻的信号掩码，以及如何适当地处理被捕获到的信号。在多进程、多线程环境中，要以进程、线程为单位来处理信号和信号掩码。

我们不能**设想**新创建的进程、线程具有和父进程、主进程完全相同的信号特征，比如：`fork`调用产生的子进程将继承父进程的信号掩码，但具有一个空的挂起信号集。

# 10.4统一事件源

**信号的统一事件源** 是一种编程技术，主要用于 Linux/Unix 系统的事件驱动编程中。它将传统的异步信号（如 SIGINT、SIGTERM 等）与 I/O 事件（如 socket 可读、文件可写等）**统一处理**，使程序能够通过单一的事件循环（如 `epoll`、`select`）来同时监听和管理这两类事件，从而简化代码逻辑、避免信号竞态、提高程序的健壮性和可维护性。

## 为什么需要统一事件源？

- **信号的异步性**：**信号是异步产生的，传统的信号处理函数（信号处理器）会在任意时刻中断程序执行，容易引发竞态条件、死锁或不可重入问题。**
- **事件循环的局限性**：**常用的 I/O 多路复用接口（如 `epoll`、`poll`）只能监听文件描述符上的事件，无法直接处理信号。**
- **统一处理的好处**：**将信号转换为 I/O 事件**后，信号可以像普通 I/O 一样被有序、同步地处理，避免了信号处理函数中的复杂限制（如只能调用异步安全函数），同时与现有的 I/O 框架自然融合。

## 实现方式

常见的实现手段包括：

### 自管道方法

1. **自管道（Self-Pipe Trick）**
   创建一个管道，在信号处理函数中向管道写入一个字节，主循环则通过 `epoll` 监听该管道的读端。当信号到来时，管道可读，事件循环触发，再从管道中读取数据并处理对应的信号。这是经典的统一事件源实现。

自管道机制的**核心**：**将信号处理函数（signal handler）的职责最小化**：它只负责“通知”主循环有信号到达，而真正的信号响应逻辑（如退出程序、重新加载配置等）则被推迟到主循环中处理。这样做能避免信号处理函数的诸多限制（只能调用异步安全函数），同时让信号与 I/O 事件共用同一个事件循环，实现“统一事件源”。

- ### 信号处理函数做了什么？

当信号（如 `SIGINT`）到来时，操作系统会调用预先注册的信号处理函数。在自管道方案中，该函数通常只做一件事：

```c
void sig_handler(int sig) {
    // 向管道写端写入一个字节（通常就是信号编号）
    write(pipe_fd[1], &sig, sizeof(sig));
}
```

这个 `write` 操作是**异步信号安全的**，可以放心在信号处理函数中调用。它执行得非常快，不会阻塞，也不会调用任何可能引发问题的函数（如 `printf`、`malloc` 等）。

- ### 管道如何变成可读？

主循环在启动时创建了一个管道 `pipe_fd[2]`，并将**管道的读端** `pipe_fd[0]` 加入 `epoll`（或 `select`/`poll`）的监听集合。当信号处理函数向写端写入一个字节后，管道中就多出了数据，此时读端立即变为**可读**。

- ### 主循环如何“处理信号”？

主循环（如 `epoll_wait`）检测到管道读端可读，就会从阻塞中返回。随后程序从管道中读取数据：

```c
int sig;
read(pipe_fd[0], &sig, sizeof(sig));
```

读取到的字节正是之前写入的信号编号。接下来，主循环就可以根据这个信号编号，安全地执行对应的处理逻辑：

- 若 `sig == SIGINT`，则进行清理、保存状态、优雅退出；
- 若 `sig == SIGHUP`，则重新读取配置文件；
- 等等。

这些处理函数可以是任何常规代码（允许调用 `printf`、动态分配内存等），因为此时程序处于主循环的同步上下文中，没有信号处理函数的种种限制。

----

- ### 为什么不在信号处理函数中直接处理？

因为信号处理函数是异步执行的，可能会中断主程序的任何代码（包括正在持有锁的临界区）。如果在信号处理函数中调用非异步安全函数，可能导致：

- **死锁**：比如主程序正在持有锁，信号处理函数又尝试获取同一把锁。
- **数据损坏**：比如 `malloc` 被中断，内部数据结构可能处于不一致状态。
- **不可重入问题**：很多标准库函数不是可重入的。

因此，最佳实践是让信号处理函数尽可能简单，只负责“通知”主循环。

------

- ### 自管道完美实现了统一事件源

通过这个机制，信号被转化为了 I/O 事件，与网络 socket、定时器、文件描述符等一起在 `epoll` 中等待。主循环只需要一个统一的调度入口，就能同时处理信号和普通 I/O，代码清晰、健壮，避免了传统信号处理的种种陷阱。

### 其他方法

2. **`signalfd`（Linux 专用）**
   Linux 提供了 `signalfd` 系统调用，它直接创建一个**文件描述符**，将信号绑定到这个描述符上。此后，**信号的到来**会使得该描述符**变为可读**，程序可**通过 `read` 获取信号信息**。这样就能直接用 `epoll` **同时监听 `signalfd` 和其他 I/O 描述符**。

3. **`eventfd` 配合信号掩码**
   某些场景下也可用 `eventfd` 配合信号阻塞和 `sigwaitinfo` 等实现类似效果，但 `signalfd` 最为直接。

## 典型应用场景

- 网络服务器（如 Nginx、Redis 等）需要优雅地处理退出信号、重新加载配置等，同时又要高效处理海量网络连接。
- 图形界面程序或游戏引擎需要同时处理用户输入、网络消息和系统信号。
- 任何基于事件循环的高并发程序，都推荐使用统一事件源来整合信号处理。

总之，统一事件源是事件驱动架构中处理异步信号的一种成熟模式，它让信号不再“游离”于事件循环之外，从而构建出更清晰、更健壮的系统。

## 统一事件源示例

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <signal.h>
#include <bits/sigaction.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <pthread.h>
#include <libgen.h>
#include <stdbool.h>

#define MAX_EVENT_NUMBER 1024 //epoll_wait 返回的最大事件数。
static int pipefd[2];//用于信号传递的管道（由 socketpair 创建），pipefd[0] 读端，pipefd[1] 写端。

int setnonblocking(int fd)
{
    int old_option = fcntl(fd,F_GETFL);//获取文件描述符当前标志
    int new_option = old_option | O_NONBLOCK;//添加非阻塞状态
    fcntl(fd,F_SETFL,new_option);//设置非阻塞I/O
    return old_option;//返回旧标志，以便后续恢复
}

void addfd(int epollfd,int fd)//向epoll添加文件描述符
{
    struct epoll_event event;
    event.data.fd = fd;
    event.events = EPOLLIN |EPOLLET;//监听可读事件，使用边缘触发(要求一次性读完所有数据)
    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&event);
    setnonblocking(fd);//将目标fd设为非阻塞
}

//信号处理函数
void sig_handler(int sig)
{
    //保留原来的errno，在函数最后恢复，以保证函数的可重入性
    int save_errno = errno;//保存errno，保证可重入性
    int msg = sig;
    send(pipefd[1],(char*)&msg,1,0);//向管道写端发送一个字节(信号值)
    errno = save_errno;//恢复errno，防止干扰被信号中断的系统调用
}

//设置信号处理函数
void addsig(int sig)
{
    struct sigaction sa;
    memset(&sa,'\0',sizeof(sa));
    sa.sa_handler = sig_handler;//注册信号处理函数
    sa.sa_flags |= SA_RESTART;//自动重启被信号中断的系统调用
    sigfillset(&sa.sa_mask);//执行处理函数时，阻塞所有信号
    assert(sigaction(sig,&sa,NULL) != -1);
}

int main(int argc,char* argv[])
{
    if(argc<=2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return -1;
    }
    const char* ip = argv[1];
    int port = atoi(argv[2]);

    int ret = 0;
    struct sockaddr_in address;
    bzero(&address,sizeof(address));
    address.sin_family = AF_INET;
    inet_pton(AF_INET,ip,&address.sin_addr);
    address.sin_port = htons(port);

    //创建监听套接字listenfd
    int listenfd = socket(PF_INET,SOCK_STREAM,0);
    assert(listenfd>=0);

    ret = bind(listenfd,(struct sockaddr*)&address,sizeof(address));
    if(ret == -1)//绑定套接字失败
    {
        printf("errno is %d\n",errno);
        return -1;
    }
    ret = listen(listenfd,5);//监听套接字listenfd,最大等待accpet连接数为5
    assert(ret != -1);

    struct epoll_event events[MAX_EVENT_NUMBER];
    int epollfd = epoll_create(5);
    assert(epollfd != -1);
    addfd(epollfd,listenfd);//将监听socket加入epoll,监听可读事件(有新的连接)

    //使用socketpair创建管道，注册pipefd[0]上的可读事件
    ret = socketpair(PF_UNIX,SOCK_STREAM,0,pipefd);
    assert(ret != -1);
    setnonblocking(pipefd[1]);//写端非阻塞，防止信号处理函数中因管道满而阻塞。
    addfd(epollfd,pipefd[0]);//读端加入epoll，以便当有信号写入时，主循环能检测到可读事件。

    //==== 新增：将标准输入加入epoll监听，实现在服务器终端输入命令控制服务器 ====
    setnonblocking(STDIN_FILENO);      // 将标准输入设为非阻塞
    addfd(epollfd, STDIN_FILENO);      // 将标准输入加入epoll，监听可读事件
    //===============================================================

    //设置一些信号的处理函数
    addsig(SIGHUP);//终端挂起
    addsig(SIGCHLD);//子进程结束
    addsig(SIGTERM);//终止
    addsig(SIGINT);//中断
    bool stop_server = false;//停止服务器为假，即不要停止

    while(!stop_server)//stop_server == false;
    {
        int number = epoll_wait(epollfd,events,MAX_EVENT_NUMBER,-1);
        if((number<0)&& (errno != EINTR))
        {
            printf("epoll failure\n");
            break;
        }
    
        for(int i = 0;i< number;i++)
        {
            int sockfd = events[i].data.fd;
            //如果就绪的文件描述符是listenfd，则处理新的连接
            if(sockfd == listenfd)
            {
                struct sockaddr_in client_address;
                socklen_t client_addresslength = sizeof(client_address);
                while(1)
                {
                    int connfd = accept(listenfd,(struct sockaddr*)&client_address,&client_addresslength);
                    if(connfd==-1)
                    {
                        if(errno == EAGAIN||errno == EWOULDBLOCK)
                        {
                            break;//所有连接已经处理完毕
                        }
                        else{break;}//处理其他错误；
                    }
                    addfd(epollfd,connfd);//将新连接加入epoll
                    printf("new client connected, fd = %d\n", connfd);
                }
            }
            //如果就绪的文件描述符是pipefd[0]，则处理信号
            else if((sockfd == pipefd[0])&&(events[i].events&EPOLLIN))
            {
                int sig;
                char signals[1024];
                ret = recv(pipefd[0],signals,sizeof(signals),0);
                if(ret == -1)//接收过程出现错误
                {
                    continue;
                }
                else if(ret == 0)//对端(管道的写端)关闭了连接
                {
                    continue;
                }
                else
                {
                    for(int i = 0;i<ret;i++)
                    {
                        switch(signals[i])
                        {
                            case SIGCHLD:
                            case SIGHUP:
                            {
                                continue;//忽略这些信号
                            }
                            case SIGTERM:
                            case SIGINT:
                            {
                                stop_server = true;//停止服务器为真，即收到终止信号，退出循环，停止服务
                            }
                        }
                    }
                }
            }
            //==== 新增：处理标准输入事件（服务器终端输入）====
            else if (sockfd == STDIN_FILENO && (events[i].events & EPOLLIN))
            {
                char cmd[128];
                int n = read(STDIN_FILENO, cmd, sizeof(cmd) - 1);
                if (n > 0)
                {
                    cmd[n] = '\0';
                    // 去除末尾的换行符（如有）
                    if (cmd[n-1] == '\n')
                        cmd[n-1] = '\0';
                    if (strcmp(cmd, "exit") == 0)
                    {
                        printf("server shutdown requested from stdin\n");
                        stop_server = true;   // 设置退出标志，关闭服务器
                    }
                }
                else if (n == 0)
                {
                    // 标准输入已关闭（例如重定向结束），可忽略或视情况退出
                }
                else
                {
                    if (errno != EAGAIN)
                        perror("read stdin");
                }
            }
            //===============================================
            // 处理已连接客户端的可读事件
            else if (events[i].events & EPOLLIN)
            {
                char buf[1024];
                while (1)
                {
                    memset(buf, 0, sizeof(buf));
                    int n = recv(sockfd, buf, sizeof(buf) - 1, 0);
                    if (n < 0)
                    {
                        if (errno == EAGAIN || errno == EWOULDBLOCK)
                            break;          // 数据已读完
                        else
                        {
                            // 读错误，关闭连接
                            printf("recv error on fd %d: %s\n", sockfd, strerror(errno));
                            close(sockfd);
                            epoll_ctl(epollfd, EPOLL_CTL_DEL, sockfd, NULL);
                            break;
                        }
                    }
                    else if (n == 0)
                    {
                        // 客户端关闭连接
                        printf("client fd %d closed\n", sockfd);
                        close(sockfd);
                        epoll_ctl(epollfd, EPOLL_CTL_DEL, sockfd, NULL);
                        break;
                    }
                    else
                    {
                        // 检查客户端是否发送了 "exit" 命令（忽略可能存在的换行符）
                        if (strncmp(buf, "exit", 4) == 0) {
                            fprintf(stderr,"client requested to close, fd %d\n", sockfd);
                            close(sockfd);
                            epoll_ctl(epollfd, EPOLL_CTL_DEL, sockfd, NULL);
                            break;  // 跳出 while(1) 读循环
                        }

                        // 成功读取数据，加上前缀后发回（不再是原样echo）
                        printf("received %d bytes from fd %d: %s", n, sockfd, buf);

                        // 构造带前缀的响应消息
                        const char *prefix = "来自服务器的数据：";
                        int prefix_len = strlen(prefix);
                        char response[2048];
                        // 确保缓冲区足够，若不足则截断原始数据
                        if (prefix_len + n > sizeof(response) - 1) {
                            n = sizeof(response) - prefix_len - 1;
                        }
                        memcpy(response, prefix, prefix_len);
                        memcpy(response + prefix_len, buf, n);
                        int to_send = prefix_len + n;

                        int total_sent = 0;
                        while (total_sent < to_send)
                        {
                            int sent = send(sockfd, response + total_sent, to_send - total_sent, 0);
                            if (sent < 0)
                            {
                                if (errno == EAGAIN || errno == EWOULDBLOCK)
                                {
                                    // 发送缓冲区满，简单处理：关闭连接（实际应缓存并注册EPOLLOUT）
                                    printf("send buffer full, close fd %d\n", sockfd);
                                    close(sockfd);
                                    epoll_ctl(epollfd, EPOLL_CTL_DEL, sockfd, NULL);
                                    break;
                                }
                                else
                                {
                                    printf("send error on fd %d: %s\n", sockfd, strerror(errno));
                                    close(sockfd);
                                    epoll_ctl(epollfd, EPOLL_CTL_DEL, sockfd, NULL);
                                    break;
                                }
                            }
                            total_sent += sent;
                        }
                        // 如果发送循环因错误退出，需要跳出外层读循环
                        if (total_sent < to_send)
                            break;
                    }
                }
            }
        }
    }
    printf("close fds\n");
    close(listenfd);
    close(pipefd[1]);
    close(pipefd[0]);
    close(epollfd);   // 建议关闭epoll文件描述符
    return 0;
}   
```

# **《深入剖析 epoll 统一事件源服务器：代码逐解与架构思想》**

- #### ==--------：**来自`deepseek`**==

## 一、代码整体功能概述

这是一个基于 **epoll + 边缘触发 (ET)** 的 TCP 回显服务器（带前缀），同时实现了 **统一事件源** 的思想，即将：

- **网络事件**（新连接、客户端数据）
- **信号事件**（SIGINT、SIGTERM 等）
- **标准输入事件**（用户在服务器终端输入命令）

全部交由 **同一个 epoll 实例** 监听和处理，从而避免了信号处理函数中的复杂逻辑，使主循环能够统一、同步地处理各种输入。

------

## 二、主要组成部分分析

### 1. 头文件

涵盖了网络编程、信号处理、文件控制、epoll、线程等所需库，代码中包含了 `<bits/sigaction.h>`（通常 `<signal.h>` 即可）以及 `<libgen.h>`（用于 `basename`）等，比较完整。

### 2. 宏定义

- `MAX_EVENT_NUMBER 1024`：epoll_wait 一次最多返回的事件数。
- 静态管道 `pipefd[2]`：用于信号传递的 socketpair 管道。

### 3. 辅助函数

- `setnonblocking(int fd)`：设置文件描述符为非阻塞模式，返回旧标志。
- `addfd(int epollfd, int fd)`：将 fd 添加到 epoll，监听 `EPOLLIN | EPOLLET`（可读且边缘触发），并自动设为非阻塞。
- `sig_handler(int sig)`：信号处理函数，向管道写端发送一个字节（信号值），保证异步安全。
- `addsig(int sig)`：注册信号处理函数，设置 `SA_RESTART` 并阻塞所有信号。

### 4. main 函数流程

#### (1) 参数解析与监听套接字初始化

- 检查命令行参数（IP 和端口），使用 `basename` 获取程序名。
- 创建 socket、bind、listen（**注意：代码中 bind 后缺少对失败的详细处理，但打印了 errno 并返回**）。

#### (2) epoll 实例创建

- `epoll_create(5)` 创建 epoll 文件描述符。
- 将监听套接字 `listenfd` 加入 epoll。

#### (3) 创建信号管道

- `socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd)` 创建全双工流管道。
- 将管道写端 `pipefd[1]` 设为非阻塞（防止信号处理函数阻塞）。
- 将管道读端 `pipefd[0]` 加入 epoll，监听可读事件。

#### (4) 将标准输入加入 epoll

- 设置 `STDIN_FILENO` 为非阻塞，并加入 epoll。这样用户在服务器终端输入命令时，主循环也能检测到。

#### (5) 注册信号

- 为 `SIGHUP`、`SIGCHLD`、`SIGTERM`、`SIGINT` 设置统一的处理函数 `sig_handler`。

#### (6) 主循环

- `while(!stop_server)` 循环，内部调用 `epoll_wait`。
- 根据就绪的 fd 分类处理：
  - `listenfd`：处理新连接（用 while 循环 accept 直到 EAGAIN，边缘触发要求）。
  - `pipefd[0]`：读取管道中的信号数据，根据接收到的信号值设置 `stop_server` 或忽略。
  - `STDIN_FILENO`：读取用户输入，若输入 "exit" 则设置 `stop_server`。
  - 普通客户端 fd：处理数据收发，包括：
    - 循环 `recv` 直到 EAGAIN 或关闭。
    - 检测到 "exit" 命令则主动关闭该客户端连接。
    - 构造带前缀的响应，并循环 `send` 直到全部发送或出错（未处理 EPOLLOUT 事件，可能因发送缓冲区满而直接关闭，这是简化处理）。

#### (7) 退出清理

- 关闭 `listenfd`、管道两端、`epollfd`。

------

## 三、统一事件源的实现思路

**核心思想**：将所有可能产生输入/事件的来源都转换为 **文件描述符**，统一由 epoll 监控，使主程序能够以一致的方式处理异步事件，避免信号处理函数中的复杂操作和竞态条件。

### 1. 信号事件的处理

- 信号处理函数中不能调用许多不安全的函数（如 printf、malloc 等）。
- 解决方案：使用 **socketpair 管道**，信号处理函数只做一件事——向管道写端写入一个字节（信号值）。这是异步信号安全的。
- 主循环监控管道的读端，当有数据可读时，再从管道中读取信号值，然后执行对应的逻辑（如设置 `stop_server`）。这样信号的处理就被“推迟”到了主循环中，安全且统一。

### 2. 标准输入事件的处理

- 将标准输入（`STDIN_FILENO`）也加入 epoll，监听可读事件。
- 当用户在终端输入内容时，主循环能够及时读取，解析命令（如 "exit"）并做出响应（如设置停止标志）。
- 这使得服务器可以通过终端直接控制，无需额外信号或进程间通信。

### 3. 网络事件的处理

- 监听套接字（`listenfd`）用于新连接，客户端套接字用于数据收发。
- 所有 socket 都设置为非阻塞，且采用边缘触发（`EPOLLET`），要求程序员在每次触发后必须循环读写直到返回 EAGAIN，以避免漏掉数据。

通过这种方式，**所有事件源都抽象成了文件描述符**，主循环只需要关心 `epoll_wait` 返回的 fd，然后根据 fd 类型分别处理，逻辑清晰且高效。

------

## 四、边缘触发（ET）的处理细节

代码中 `addfd` 设置了 `EPOLLET`，因此在处理监听套接字和客户端读写时都采用了 **while 循环**：

- **监听套接字**：`while(accept) {...}` 直到返回 EAGAIN，确保所有挂起的连接都被接受。
- **客户端读**：`while(recv) {...}` 直到 EAGAIN 或连接关闭，确保读完本次触发时的所有数据。
- **客户端写**：`while(send) {...}` 直到全部发送完成或 EAGAIN（这里简化了，未注册 EPOLLOUT 事件，若 EAGAIN 直接关闭连接，实际应缓存数据并等待 EPOLLOUT）。

ET 模式能减少 epoll 事件触发的次数，但要求程序必须一次性处理完数据，否则可能遗漏。

------

## 五、关键点深度剖析

### 1. 信号处理的异步安全

- `sig_handler` 中保存/恢复 `errno`，保证不影响被中断的系统调用。
- 使用 `send` 向管道写数据是安全的（在 Linux 上，send 是异步信号安全的）。
- 信号注册时使用 `sigfillset(&sa.sa_mask)` 阻塞所有信号，防止处理函数被嵌套打断。

### 2. 非阻塞 I/O 的必要性

- 所有加入 epoll 的 fd（包括监听套接字、管道、标准输入）都设置为非阻塞，避免在读写时因资源暂时不可用而阻塞 epoll 主循环。

### 3. 错误处理

- 对 `accept`、`recv`、`send` 的错误进行了判断，区分 EAGAIN（正常无数据）和其他致命错误，并适当关闭连接、从 epoll 中移除。
- 当客户端发送 "exit" 时，服务器主动关闭连接，并在日志中打印（使用 `fprintf(stderr)` 立即刷新）。

### 4. 缓冲区管理

- 读取客户端数据使用固定大小 `buf[1024]`，注意留出末尾 `\0` 位置。
- 构造响应时，使用临时大缓冲区 `response[2048]`，并检查溢出（若原始数据 + 前缀过长，则截断）。
- 发送时循环保证全部发送，但若发送缓冲区满返回 EAGAIN，代码选择直接关闭连接——这是一个简化，生产环境应缓存剩余数据并监听 EPOLLOUT。

### 5. 程序退出机制

- 两种方式触发退出：
  - 收到 SIGINT/SIGTERM 信号（通过管道传递给主循环）。
  - 在服务器终端输入 "exit"（通过标准输入事件）。
- 退出前关闭所有打开的 fd，释放资源。

------

## 六、代码执行流程逐步解释

1. **启动参数检查** → 创建监听 socket → bind → listen。
2. **创建 epoll 实例** → 将 `listenfd` 加入 epoll。
3. **创建 socketpair 管道** → 将 `pipefd[0]` 加入 epoll，写端设为非阻塞。
4. **将标准输入 `STDIN_FILENO` 加入 epoll**（设为非阻塞）。
5. **注册信号处理函数**（SIGINT、SIGTERM 等）。
6. **进入主循环**：
   - 调用 `epoll_wait` 等待事件。
   - 遍历返回的事件数组：
     - 若为 `listenfd`：`accept` 所有新连接，每个新连接加入 epoll。
     - 若为 `pipefd[0]`：读取管道数据，每个字节代表一个信号值，若为 SIGINT/SIGTERM 则设置 `stop_server = true`。
     - 若为 `STDIN_FILENO`：读取一行输入，若为 "exit" 则设置 `stop_server = true`。
     - 若为其他 fd（客户端）：循环 `recv` 数据：
       - 读错误或对端关闭：关闭连接并移除。
       - 读到数据：检查是否包含 "exit" 命令，若是则关闭连接。
       - 否则构造响应并循环 `send` 发回。
7. **退出循环后**：关闭所有打开的文件描述符，程序结束。

------

## 七、潜在问题与改进建议

1. **发送缓冲区满的处理**：当前若 `send` 返回 EAGAIN 则直接关闭连接，这会导致数据丢失。更好的做法是：将剩余数据缓存到每个连接的发送缓冲区，并修改 epoll 事件为 `EPOLLIN | EPOLLOUT`，等待可写时继续发送。
2. **信号集处理**：`sigfillset(&sa.sa_mask)` 会阻塞所有信号，包括 SIGINT 等，但处理函数运行期间这些信号会被阻塞，可能会导致信号丢失。但在这个简单示例中影响不大。
3. **缺少 `SO_REUSEADDR`**：bind 前未设置，可能导致端口被占用时无法快速重启。
4. **错误处理**：`bind` 失败后只打印 errno 并返回 -1，但未关闭 listenfd，可能造成资源泄漏。
5. **标准输入的非阻塞**：将标准输入设为非阻塞，如果用户在终端输入慢，可能导致读入不完整（例如只读到部分行），这里简单按行处理可能不够健壮，但示例可以接受。
6. **未处理 SIGPIPE**：向已关闭的 socket 写会触发 SIGPIPE 导致进程退出，通常应忽略该信号或设置 `MSG_NOSIGNAL`。
7. **epoll 事件类型检查**：代码中只检查了 `EPOLLIN`，未处理异常事件（如 `EPOLLERR`、`EPOLLHUP`），应当添加相应处理。

## 运行截图

![统一事件源](D:\Typora\typora_work\Linux高性能服务器编程\统一事件源.png)
