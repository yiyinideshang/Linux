# 扩展与实用建议

## 常用信号调试命令

- `kill -l` 列出所有信号。
- `ps -e` 查看进程 PID。
- `strace` 跟踪系统调用，观察信号处理过程。
  - **`starce`**工具的使用见：`D:\Typora\typora_work\Linux高性能服务器编程\9.IO复用的高级应用1非阻塞connect.md`
- `gdb` 中处理信号的方法（`handle` 命令）。

## 实践练习

- 例如：编写一个程序，使用 `sigaction` 捕获 `SIGUSR1`，并在处理函数中打印发送者 PID；另一个进程用 `kill` 发送信号。
- 使用 `sigpending` 和 `sigsuspend` 实现简单的等待信号机制。

## 指出常见陷阱

- 不能在信号处理函数中调用非异步信号安全函数，否则可能导致死锁或 crash。
- `sigprocmask` 在多线程中的未定义行为，应使用 `pthread_sigmask`。
- 如果信号处理函数中设置了全局变量（如 `flag`），应使用 `volatile sig_atomic_t` 类型保证原子访问。

# 10.1Linux信号概述

## 10.1.1 发送信号

`Linux`下，**一个进程个其他进程发送信号**的`API`是`kill`函数，定义如下:

```c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid,int sig);
```

该函数把信号`sig`发送诶目标进程；

### 	`pid`参数

目标进程由`pid`参数指定，取值及含义如下：

| `pid`参数 | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| `pid>0`   | 信号发送给`PID`为`pid`的进程                                 |
| `pid=0`   | 信号发送给本进程组内的其他进程                               |
| `pid=-1`  | 信号发送给除`init`进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限 |
| `pid<-1`  | 信号发送给组`ID`为`-pid`的进程组中的所有成员                 |

### 	`sig`参数

`Linux`定义的信号值都大于0，如果`sig`的取值为0，则kill函数不发送任何信号，但将`sig`设置为0可以用来检测目标进程或目标进程组是否存在，因为检查工作总是在信号发送之前就执行。不过这种检测方式是不可靠的，一方面因为进程`PID`的回绕，另一方面这种检测方法不是原子性的。

### 	返回值

该函数成功返回0，失败返回-1并设置`errno`，以下是几种可能的`errno`

`kill`出错的情况

| `errno`  | 含义                                     |
| -------- | ---------------------------------------- |
| `EINVAL` | 无效的信号                               |
| `EPERM`  | 该进程没有权限发送信号给任何一个目标进程 |
| `ESRCH`  | 目标进程或者进程组不存在                 |

## 10.1.2 信号处理方式

**目标进程在收到信号后，需要定义一个接受函数来处理之。**信号处理函数的原型如下：

```c
#include <signal.h>
typedef void(*_sighandler_t) (int);
```

信号处理函数 只有一个 **整数参数，用来指定信号类型**。该函数是**可重入**的，在信号处理函数中**严禁调用一些不安全的函数**

除了**用户自定义信号处理函数**之外，`bits/signum.h`头文件中还定义了信号的两种其他处理方式-----

**`SIG_DFL`和`SIG_IGN`**

```c
#include <bits/signum.h>
#define SIG_DFL ((_sighandler_t) 0)
#define SIG_IGN ((_sighandler_t) 1)
```

`SIG_DFL`：表示使用**信号的默认处理方式**。

`SIG_IGN`：表示**忽略目标信号**。

- 信号的默认处理方式有以下几种：
  - 结束进程 `Term`
  - 忽略信号 `Ign`
  - 结束进程并生成核心转储文件`Core`
  - 暂停进程 `Stop`
  - 继续进程 `Cont`

<!--什么是异步信号安全函数-->

<!--常见的安全函数（如 `write`、`signal` 本身、`_exit`）和不安全函数（如 `printf`、`malloc`、`pthread` 函数）。-->



## 10.1.3 Linux信号

`Linux`的可用信号都定义在`bits/signum.h`头文件中，其中包括标准信号和`POSIX`实时信号，以下是`Linux`标准信号

| 信号     | 起源  | 默认行为 | 含义                         |
| -------- | ----- | -------- | ---------------------------- |
| `SIGHUP` | POSIX | Term     | 控制终端挂起                 |
| `SIGINT` | ANSI  | Term     | 键盘输入以中断进程(`ctrl+C`) |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |
|          |       |          |                              |

### 实时信号

实时信号（`SIGRTMIN` 到 `SIGRTMAX`）的特点：支持排队、可附带数据（通过 `sigqueue`），可以在 `sigaction` 的 `siginfo_t` 中获取。

## 10.1.4 中断系统调用

使用`sigaction`函数，为信号设置`SA_RESTART`标志以自动重启被该信号中断的系统调用。

对于**默认行为是 暂停进程的信号**(如`SIGSTOP`、`SIGTTIN`)，如果没有为他们设置信号处理函数，则它们也可以中断某些系统调用(如`connect`、`epoll`、`epoll_wait`).`POSIX`中没有这种规定，这是`Linux`独有的。

# 10.2 信号函数

## 10.2.1 `signal`系统调用

```c
#include <signal.h>
typedef void (*sighandler_t)(int);//sighandler_t是这样一个类型，void (*)(int)
sighandler_t signal(int sig, sighandler_t _handler);
```

```c
void (*signal(int sig, void (*func)(int)))(int);
```

### 	参数解释

- **`sig`**：整数，指定要操作的信号类型（例如 `SIGINT`、`SIGTERM` 等）。
- **`_handler`**：`sighandler_t` 类型的函数指针，用于指定信号`sig`的处理函数
  - `sighandler_t` 被定义为：`typedef void (*sighandler_t)(int);`
  - 即 `_handler` 指向一个 **参数为 `int`、返回值为 `void` 的函数**（该 `int` 参数会被传入触发信号的编号）。（即指向信号`sig`的处理函数）
  - `_handler` 也可以是两个特殊宏：
    - `SIG_DFL`：默认处理（由系统决定，如终止进程、忽略等）。
    - `SIG_IGN`：忽略该信号。

###  	返回值

函数返回结果： 前一次对该`sig`信号 调用`signal`函数时传入的函数指针，

- **成功**：返回一个 `sighandler_t` 类型的函数指针，指向 **本次调用之前** 为该信号 `sig` 安装的处理函数。(上次调用`signal`的第二个参数)
  - 可能是上一次调用 `signal` 时传入的自定义函数指针。
  - 也可能是 `SIG_DFL` 或 `SIG_IGN`
    - 如果从未对该信号调用过 `signal`，则返回初始默认值 `SIG_DFL` 或 `SIG_IGN`（取决于系统默认行为）。
- **失败**：返回 `SIG_ERR`（也是一个 `sighandler_t` 类型的特殊值），并设置 `errno` 以指示错误。

## 10.2.2 `sigaction`系统调用

`sigaction` 是 UNIX/Linux 系统中用于**检查或更改信号处理动作**的系统调用。它比传统的 `signal` 函数更加强大、可靠，并且是 POSIX 标准推荐使用的信号管理接口。

### 1. 函数原型

```c
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

- **`signum`**：要操作的信号编号（除 `SIGKILL` 和 `SIGSTOP` 外，所有信号均可捕获或忽略）。
- **`act`**：如果非空，指向一个 `struct sigaction` 结构体，用于指定对 `signum` 的新处理方式。
- **`oldact`**：如果非空，用于返回之前对 `signum` 的处理方式（即上一次设置的 `struct sigaction` 内容）。
- **返回值**：成功返回 0；失败返回 -1，并设置 `errno`。

### 2. `struct sigaction` 结构体

```c
struct sigaction {
    union
    {
	void     (*sa_handler)(int);        /* 简单信号处理函数 */
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 带额外信息的处理函数 
    }
    
    sigset_t   sa_mask;                  /* 在处理函数执行期间要阻塞的信号集 */
    int        sa_flags;                  /* 控制信号处理行为的标志 */
    void     (*sa_restorer)(void);       /* 已废弃，不应使用: 通常不关心，设为 NULL 即可*/
};
```

- **`sa_handler` 与 `sa_sigaction`**：二者是互斥的，通过 `sa_flags` 中的 `SA_SIGINFO` 标志来选择使用哪一个。若设置了 **`SA_SIGINFO`**，则使用 `sa_sigaction`；否则使用 `sa_handler`。
  - `sa_handler`：与 `signal` 的处理函数类似，接收一个 int 参数（信号编号），返回 void。
  - `sa_sigaction`：接收三个参数：
    - `int`：信号编号。
    - `siginfo_t *`：指向一个包含信号详细信息的结构体（如发送进程 PID、用户 ID、信号值、伴随数据等）。
    - `void *`：通常指向 `ucontext_t` 结构体，包含信号发生时的上下文信息（可忽略）。
- **`sa_mask`**：指定在调用处理函数期间，除了当前信号自动被屏蔽外，额外要阻塞的信号集。这样可以防止在处理某个信号时，被其他信号中断。当处理函数返回后，原信号屏蔽字会自动恢复。
  - `sa_mask`是**信号集`sigset_t`**(同`_sigset_t`)类型，该类型**指定一组信号**，==关于信号集，见后文==
- **`sa_flags`**：一组位掩码，用于修改信号处理的行为。常用值包括：
  - `SA_RESTART`：使被信号中断的系统调用自动重启（例如 `read`、`write`），从而避免 `EINTR` 错误。
  - `SA_SIGINFO`：使用 `sa_sigaction` 作为处理函数，而非 `sa_handler`。
  - `SA_NOCLDSTOP`：仅在 `signum` 为 `SIGCHLD` 时有效，表示当子进程停止（而不是终止）时不产生 `SIGCHLD` 信号。
  - `SA_RESETHAND`：处理函数执行一次后，将信号动作恢复为默认值（`SIG_DFL`），类似 `signal` 的旧语义。
  - `SA_NODEFER`：在处理函数执行期间，不自动屏蔽当前信号（即允许递归发送该信号）。
  - 其他标志可参考 man 手册。

### 3. 与 `signal` 的比较

| 特性             | `signal`                     | `sigaction`                          |
| :--------------- | :--------------------------- | :----------------------------------- |
| **可移植性**     | 行为因系统而异（SysV/BSD）   | POSIX 标准，行为一致                 |
| **可靠性**       | 可能不支持信号排队、丢失信息 | 支持可靠信号（排队、额外信息）       |
| **信号屏蔽字**   | 无法指定额外阻塞的信号       | 可通过 `sa_mask` 指定                |
| **获取详细信息** | 不能                         | 通过 `SA_SIGINFO` 可获得发送方信息等 |
| **系统调用重启** | 无法控制                     | 可通过 `SA_RESTART` 控制             |
| **一次性处理**   | 有些实现默认一次性           | 可通过 `SA_RESETHAND` 控制           |
| **递归发送控制** | 无法控制                     | 可通过 `SA_NODEFER` 控制             |

简言之，**`sigaction` 是 `signal` 的超集**，提供了精细的控制和更多的功能。

# 10.3 信号集

`Linux`使用**信号集（signal set）**，用于表示一组信号，它是一种数据类型（`sigset_t`）。

信号集函数就是用来操作这种数据类型的工具，常用于设置进程的信号屏蔽字（blocked set）、等待信号集等场景。它们是实现精确信号控制的基础。

## 1. 为什么需要信号集？

- 进程可以**阻塞**某些信号，即暂时不递送它们，直到解除阻塞。
- 进程可能需要**等待**一组信号中的任意一个到达（如 `sigsuspend`、`sigwait`）。
- 信号处理函数执行期间，可以指定额外的信号被阻塞（通过 `sigaction` 的 `sa_mask` 字段）。

所有这些操作都需要一种方式来表示“一组信号”，这就是信号集的作用。

## 2. 信号集数据类型：`sigset_t`

在Linux 系统（特别是 glibc）中的实际内部表示：

```c
#define _SIGSET_NWORDS (1024/(8*sizeof(unsigned long int)))
typedef struct {
    unsigned long int _val[_SIGSET_NWORDS];
} _sigset_t;
```

从以上定义可以知道，`sigset_t`实际上是一个长整型数组，  `_val` 数组是一个位掩码（`bitmask`），每个位代表一个信号。这种定义方式 和 文件描述符 `fd_set`类似 **==`select`系统调用==**

- **应用程序不应该直接操作 `_val` 数组，应使用函数操作。**
- **接口层面，我们把它看作不透明的**——即我们只知道它的名字，而不知道它的内部布局，并且我们应该通过专门的操作函数来使用它。
- 不能直接操作它的内部表示，而必须通过专门的函数来**设置**、**修改**、**删除**和**查询信号集**。

## 10.3.1信号集函数

这些函数的原型都在 `<signal.h>` 中定义，成功时返回 0，失败返回 -1 并设置 `errno`（但通常不会失败，除非传入无效指针）。

```c
#include <signal.h>
int sigemptyset(sigset_t *set);//清空信号集
int sigfillset(sigset_t *set);//填充所有信号
int sigaddset(sigset_t *set, int signum);//将信号signum添加到信号集中
int sigdelset(sigset_t *set, int signum);//将信号signum从信号集中删除
int sigismember(const sigset_t *set, int signum);//测试signnum是否在信号集中
```

- `sigemptyset()`
  - 将信号集 `set` 初始化为**空**（不包含任何信号）。
  - 在使用任何信号集之前，必须先调用 `sigemptyset` 或 `sigfillset` 进行初始化。
- `sigfillset()`
  - 将信号集 `set` 初始化为包含**所有已定义信号**（通常包括所有标准信号，可能不包括实时信号范围以外的值）。

- `sigaddset()`
  - 将信号 `signum` 添加到信号集 `set` 中。
- `sigdelset()`
  - 将信号 `signum` 从信号集 `set` 中移除。
- `sigismember()`
  - 检查 `signum` 是否是 `set` 的成员。
  - 返回值：如果 `signum` 在 `set` 中，返回 **1**；不在则返回 **0**；出错返回 -1。

*这些函数封装了内部细节，确保无论内部实现如何，都能正确操作。例如，在 Linux 上，`sigaddset` 可能会计算出信号编号对应的数组索引和位掩码，然后设置 `_val[索引]` 的对应位。但在应用程序看来，它只是“添加信号”的抽象操作。*

- ## 为什么说`sigset_t`是不透明的

  - **从 API 设计角度**：POSIX 规范将 `sigset_t` 定义为一个**不完整的类型**（可能通过前向声明），但实际实现中通常会给出完整定义，以便编译器分配内存。然而，规范强调应用程序**必须通过函数来操作**，而不能依赖其内部结构。这就是“**不透明数据类型**”的核心含义。
- **从编程实践角度**：优秀的编程习惯是始终使用操作函数，而不是直接访问成员。即使你知道内部结构，直接访问也会带来上面提到的风险和可移植性问题。

## 10.3.2 进程信号掩码

前文提到，可以利用`sigaction`结构体的`sa_mask` 成员来设置进程的信号掩码，此外，下面函数也可以用于设置或查看进程的信号掩码

==`sa_mask` 只是临时掩码，而 `sigprocmask` 设置的是进程的持久掩码。==

### 什么是信号掩码

指定在调用处理函数期间，除了当前信号自动被屏蔽外，**额外要阻塞的信号集**。这样可以防止在处理某个信号时，被其他信号中断。

### 	函数原型及参数解释

```c
#include <signal.h>
int sigprocmask(int _how,_const sigset_t* _set,sigset_t* _oset);
```

- `_set`参数 指定新的信号掩码，它是一个指向信号集`sigset_t`的指针，指定本次调用要操作的具体信号集合。
- `_oset`参数 如果`_oset`不为`NULL`，函数会调用前的旧信号掩码保存其中。如果只关心修改掩码而不需要旧值，可以将其设置为`NULL`。
- 如果 `_set`参数不为`NULL`，则`_how`参数 **指定设置进程信号掩码的方式(指示如何修改信号掩码)**，其值如下表：

| 参数值        | 行为描述                                                     |
| :------------ | :----------------------------------------------------------- |
| `SIG_BLOCK`   | 将 `_set` 指向的信号集添加到当前的阻塞集中（取并集u）。<br />新的进程信号掩码是当前值和`_set`指向的信号集的并集 |
| `SIG_UNBLOCK` | 将 `_set` 指向的信号集从当前的阻塞集中移除。(从当前信号掩码中移除 set 中的信号) |
| `SIG_SETMASK` | 将当前的阻塞集直接设置为 `_set` 指向的信号集。               |

- **如果`_set`参数为`NULL`**，则进程信号掩码不变，忽略`_how`参数，但此时可以**通过`_oset`来返回当前信号掩码的值**

### 	返回值

`sigprocmask` 成功返回0，失败返回-1,并设置`errno`,常见的错误是 `EINVAL`，表示 `how` 参数的值无效。

### 使用示例：

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main() {
    sigset_t newmask, oldmask;

    // 1. 初始化一个信号集，并添加想要阻塞的 SIGINT
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);

    // 2. 阻塞 SIGINT 信号，并保存旧的信号掩码
    if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1) {
        perror("sigprocmask SIG_BLOCK error");
        return 1;
    }
    printf("SIGINT is now blocked. Try pressing Ctrl+C for 5 seconds...\n");

    // 3. 执行关键代码段（例如模拟耗时操作）
    sleep(5);

    // 4. 使用 SIG_SETMASK 恢复原来的信号掩码，从而解除对 SIGINT 的阻塞
    //    此时，如果在阻塞期间收到了 SIGINT，它会被立即递送
    if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1) {// 解除阻塞，挂起的 SIGINT 立即递送
        perror("sigprocmask SIG_SETMASK error");
        return 1;
    }
    printf("Signal mask restored. SIGINT is now unblocked.\n");

    // 5. 再次暂停，以便观察是否有信号被递送
    printf("Pausing for 5 seconds. Try pressing Ctrl+C now...\n");
    sleep(5);

    return 0;
}
```

- 这个代码，在阻塞期间将`SIGINT`(键盘输入中断进程`ctrl+c`)阻塞

  - ## **阻塞期间**：

  ```c
  sigprocmask(SIG_BLOCK, &newmask, &oldmask);   // 阻塞开始
  sleep(5);                                      // 阻塞期间
  sigprocmask(SIG_SETMASK, &oldmask, NULL);     // 阻塞结束，恢复原掩码
  ```

- 如果在阻塞期间收到被阻塞的信号`SIGINT`时，并不会直接**丢失**该信号，而是被内核记录下来，变为**挂起(pending)**状态。也就是说，内核知道这个信号来了，但因为当前进程（或线程）不想立即处理它，所以暂时搁置。

- 如果信号是**标准信号**（如 `SIGINT`），在阻塞期间如果多次收到同一个信号，**通常只会记录一次**（即不会排队），而**实时信号会排队。**
- 在阻塞期间，该信号的处理函数**不会被执行**(当前是默认处理函数，将`Ctrl+C`作为中断进程的标志)，进程也不会被终止（如果是默认终止行为）。

当通过 `sigprocmask(SIG_SETMASK, &oldmask, NULL)` **解除阻塞**后，内核会检查当前是否有**挂起的信号**。如果发现有之前被阻塞的信号（比如你在那 5 秒里按了 `Ctrl+C` 产生的 `SIGINT`），那么内核会在 `sigprocmask` 函数**返回之前**（或返回后马上）将那个挂起的信号**递送给进程**。

“递送”意味着：

- 如果该信号有自定义的处理函数，会立即执行那个函数。
- 如果该信号的处置是默认动作（比如 `SIGINT` 默认终止进程），那么进程会被终止。

所以，在你代码中恢复掩码之后，**如果阻塞期间按过 Ctrl+C**，那么恢复掩码后程序会立即收到 `SIGINT`，很可能在打印 `"Signal mask restored..."` 之前或之后**立即终止**，导致最后的 `sleep(5)` 根本来不及执行。

如果在阻塞期间没按过`Ctrl+C`，在` printf("Pausing for 5 seconds. Try pressing Ctrl+C now...\n");`之后再按`Ctrl+C`，会调用默认处理函数，将`Ctrl+C`作为中断进程的标志，会被执行。

### 阻塞和忽略

（阻塞是暂时不递送，但信号仍然挂起；忽略是递送后丢弃）。

### 下面的代码将更加直观：

````c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void sigint_handler(int sig) {
    write(STDOUT_FILENO, "\nCaught SIGINT!\n", 16);
    //使用write而不是printf,是因为
    //write 是一个系统调用，直接陷入内核，不涉及用户态的复杂缓冲和锁机制，它是异步信号安全的，可以在信号处理函数中安全地使用。
}

int main() {
    struct sigaction sa = { .sa_handler = sigint_handler };
    sigaction(SIGINT, &sa, NULL);

    sigset_t newmask, oldmask;
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);

    sigprocmask(SIG_BLOCK, &newmask, &oldmask);
    printf("SIGINT blocked. You have 5 seconds to press Ctrl+C...\n");
    sleep(5);   // 在这期间按 Ctrl+C，信号被挂起

    printf("Restoring mask...\n");
    sigprocmask(SIG_SETMASK, &oldmask, NULL);   // 解除阻塞，挂起的 SIGINT 立即递送
    // 注意：此处可能不会立即执行下一行，因为信号处理函数会先运行

    printf("Mask restored. Doing another sleep...\n");
    sleep(5);
    return 0;
}
````

```c
yishang@yishang-virtual-machine:~/文档/Linux高性能服务器编程$ ./test 
SIGINT blocked. You have 5 seconds to press Ctrl+C...
^C
Restoring mask...

Caught SIGINT!
Mask restored. Doing another sleep...
^C
Caught SIGINT!
```

将`SIGINT`信号自定义了一个处理函数，而不是默认的中断进程了，当收到这个信号时只会	调用 `write` 系统调用向标准输出（文件描述符`STDOUT_FILENO`，即1）写入一串字符，而不是中断进程

当在**阻塞`SIGINT`期间**，按下 `Ctrl+C`，则将这个信号**挂起**，**当结束阻塞后，立即投递给进程**，输出这个信号 处理函数的结果(`Caught SIGINT`!)

当**不阻塞`SIGINT`期间**，也就是`sigprocmask(SIG_SETMASK, &oldmask, NULL);//解除阻塞`之后，按下`Ctrl+C`，则将立即投递给进程，输出这个信号 处理函数的结果(`Caught SIGINT`!)

## 10.3.3 被挂起的信号

   设置进程信号掩码后，**被屏蔽的信号**将不会被进程接收。如果给进程发送被屏蔽的信号，那么操作系统将该信号设置为进程的一个被**挂起**的信号。如果取消对被挂起的信号的屏蔽，则它能立即被进程接收到。

### 函数原型

- **获取进程当前被挂起的信号集**:

```c
#include<signal.h>
int sigpending(sigset_t* set);
```

`set`参数用于保存被挂起的信号集。

进程即使多次收到同一个被挂起的信号，`sigpending`函数也只能反映一次，并且，当再次使用`sigpromark`使该被挂起的信号生效时，该信号的处理函数也只能被触发一次。

### 返回值：

`sigpending`成功返回0，失败返回-1，并设置`errno`。

### 提醒：

要始终清楚地知道进程在每个运行时刻的信号掩码，以及如何适当地处理被捕获到的信号。在多进程、多线程环境中，要以进程、线程为单位来处理信号和信号掩码。

我们不能**设想**新创建的进程、线程具有和父进程、主进程完全相同的信号特征，比如：`fork`调用产生的子进程将继承父进程的信号掩码，但具有一个空的挂起信号集。

# 10.4统一事件源

**信号的统一事件源** 是一种编程技术，主要用于 Linux/Unix 系统的事件驱动编程中。它将传统的异步信号（如 SIGINT、SIGTERM 等）与 I/O 事件（如 socket 可读、文件可写等）**统一处理**，使程序能够通过单一的事件循环（如 `epoll`、`select`）来同时监听和管理这两类事件，从而简化代码逻辑、避免信号竞态、提高程序的健壮性和可维护性。

## 为什么需要统一事件源？

- **信号的异步性**：**信号是异步产生的，传统的信号处理函数（信号处理器）会在任意时刻中断程序执行，容易引发竞态条件、死锁或不可重入问题。**
- **事件循环的局限性**：**常用的 I/O 多路复用接口（如 `epoll`、`poll`）只能监听文件描述符上的事件，无法直接处理信号。**
- **统一处理的好处**：**将信号转换为 I/O 事件**后，信号可以像普通 I/O 一样被有序、同步地处理，避免了信号处理函数中的复杂限制（如只能调用异步安全函数），同时与现有的 I/O 框架自然融合。

## 实现方式

常见的实现手段包括：

### 自管道方法

1. **自管道（Self-Pipe Trick）**
   创建一个管道，在信号处理函数中向管道写入一个字节，主循环则通过 `epoll` 监听该管道的读端。当信号到来时，管道可读，事件循环触发，再从管道中读取数据并处理对应的信号。这是经典的统一事件源实现。

自管道机制的**核心**：**将信号处理函数（signal handler）的职责最小化**：它只负责“通知”主循环有信号到达，而真正的信号响应逻辑（如退出程序、重新加载配置等）则被推迟到主循环中处理。这样做能避免信号处理函数的诸多限制（只能调用异步安全函数），同时让信号与 I/O 事件共用同一个事件循环，实现“统一事件源”。

- ### 信号处理函数做了什么？

当信号（如 `SIGINT`）到来时，操作系统会调用预先注册的信号处理函数。在自管道方案中，该函数通常只做一件事：

```c
void sig_handler(int sig) {
    // 向管道写端写入一个字节（通常就是信号编号）
    write(pipe_fd[1], &sig, sizeof(sig));
}
```

这个 `write` 操作是**异步信号安全的**，可以放心在信号处理函数中调用。它执行得非常快，不会阻塞，也不会调用任何可能引发问题的函数（如 `printf`、`malloc` 等）。

- ### 管道如何变成可读？

主循环在启动时创建了一个管道 `pipe_fd[2]`，并将**管道的读端** `pipe_fd[0]` 加入 `epoll`（或 `select`/`poll`）的监听集合。当信号处理函数向写端写入一个字节后，管道中就多出了数据，此时读端立即变为**可读**。

- ### 主循环如何“处理信号”？

主循环（如 `epoll_wait`）检测到管道读端可读，就会从阻塞中返回。随后程序从管道中读取数据：

```c
int sig;
read(pipe_fd[0], &sig, sizeof(sig));
```

读取到的字节正是之前写入的信号编号。接下来，主循环就可以根据这个信号编号，安全地执行对应的处理逻辑：

- 若 `sig == SIGINT`，则进行清理、保存状态、优雅退出；
- 若 `sig == SIGHUP`，则重新读取配置文件；
- 等等。

这些处理函数可以是任何常规代码（允许调用 `printf`、动态分配内存等），因为此时程序处于主循环的同步上下文中，没有信号处理函数的种种限制。

----

- ### 为什么不在信号处理函数中直接处理？

因为信号处理函数是异步执行的，可能会中断主程序的任何代码（包括正在持有锁的临界区）。如果在信号处理函数中调用非异步安全函数，可能导致：

- **死锁**：比如主程序正在持有锁，信号处理函数又尝试获取同一把锁。
- **数据损坏**：比如 `malloc` 被中断，内部数据结构可能处于不一致状态。
- **不可重入问题**：很多标准库函数不是可重入的。

因此，最佳实践是让信号处理函数尽可能简单，只负责“通知”主循环。

------

- ### 自管道完美实现了统一事件源

通过这个机制，信号被转化为了 I/O 事件，与网络 socket、定时器、文件描述符等一起在 `epoll` 中等待。主循环只需要一个统一的调度入口，就能同时处理信号和普通 I/O，代码清晰、健壮，避免了传统信号处理的种种陷阱。

### 其他方法

2. **`signalfd`（Linux 专用）**
   Linux 提供了 `signalfd` 系统调用，它直接创建一个**文件描述符**，将信号绑定到这个描述符上。此后，**信号的到来**会使得该描述符**变为可读**，程序可**通过 `read` 获取信号信息**。这样就能直接用 `epoll` **同时监听 `signalfd` 和其他 I/O 描述符**。

3. **`eventfd` 配合信号掩码**
   某些场景下也可用 `eventfd` 配合信号阻塞和 `sigwaitinfo` 等实现类似效果，但 `signalfd` 最为直接。

## 典型应用场景

- 网络服务器（如 Nginx、Redis 等）需要优雅地处理退出信号、重新加载配置等，同时又要高效处理海量网络连接。
- 图形界面程序或游戏引擎需要同时处理用户输入、网络消息和系统信号。
- 任何基于事件循环的高并发程序，都推荐使用统一事件源来整合信号处理。

总之，统一事件源是事件驱动架构中处理异步信号的一种成熟模式，它让信号不再“游离”于事件循环之外，从而构建出更清晰、更健壮的系统。
