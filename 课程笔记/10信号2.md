# 10.5网络编程相关信号

# 10.5.1 	`SIGHUP`：控制终端挂起

# 10.5.2 `SIGPIPE`：往读端被关闭的管道或者socket连接中写数据

## 1. 什么是 `SIGPIPE` 信号

- **定义**：当进程向一个**对端读端已经关闭**（即数据接收方不再接收数据）的管道（`Pipe`）或 `Socket` 连接中写入数据时，操作系统会向该进程发送 `SIGPIPE` 信号。
- **默认行为**：收到 `SIGPIPE` 的进程会**直接终止**。
- **目的**：防止数据被写入到永远无法被读取的“黑洞”，避免进程阻塞和资源浪费，并及时通知程序连接已破裂。

## 2. 理解“读端关闭”

“读端关闭”指的是**数据接收方不再从通道中读取数据**，即对端的读端已被关闭。由于管道和 Socket 的通信模型不同，需要分别理解：

- **管道（单向通信）**：只有一个读端和一个写端。读端关闭意味着整个通道失效，写端再写入就会触发 `SIGPIPE`。
  **符号表示**：`A读(✘) ← B写`（A 关闭读端，B 写触发 `SIGPIPE`）
- **Socket（全双工）**：有两个独立的数据流。`SIGPIPE` 的触发条件是**对端的读端关闭**，即本端写入时数据无法送达对端。
  **符号表示**：`A读(✘) ← B写`（A 关闭读端，B 写触发 `SIGPIPE`）

## 3. 所有关闭场景详细分析

下表涵盖了管道和 Socket 中所有可能的关闭情况，并说明了写操作是否触发 `SIGPIPE` 以及 `poll`/`epoll` 会触发什么事件（`EPOLL` 事件类似，此处以 `poll` 为例）。

| 类型       | 关闭动作（谁关闭了什么）                 | 符号表示                                       | 本端写操作是否触发 `SIGPIPE`（谁写）                         | `poll`/`epoll` 事件（哪个描述符，什么事件，是否需要注册）    |
| :--------- | :--------------------------------------- | :--------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **管道**   | 读端关闭（A 关闭读端）                   | `A读(✘) ← B写`                                 | **B 写触发 `SIGPIPE`**                                       | **B 写端**：`POLLHUP`（条件事件，无需注册）                  |
| **管道**   | 写端关闭（B 关闭写端）                   | `A读 ← B写(✘)`                                 | B 写端已关闭，若 B 再写则触发 `SIGPIPE`（自身写端关闭）      | **A 读端**：先 `POLLIN`（若有剩余数据），数据读完后再触发 `POLLHUP`（条件事件） |
| **Socket** | 对端关闭读端（**B 关闭读端**）           | A写 → B读(✘)                                   | **A 写触发 `SIGPIPE`**                                       | **A 写端**：无直接 `poll` 事件。写操作导致对端 `RST` 后，后续可能触发 `POLLERR` 或 `POLLHUP`。 |
| **Socket** | 对端关闭写端（**B 关闭写端**）（半关闭） | `A读 ← B写(✘)`                                 | A 写不受影响（除非 B 也关闭读端）<br />B 写端已关，若 B 再写则触发 `SIGPIPE` | **A 读端**：若注册 `POLLRDHUP`，则触发 `POLLRDHUP`；否则只触发 `POLLIN`（可读且 `read` 返回 0） |
| **Socket** | 对端完全关闭（**B 关闭读写两端**）       | B 读写均关<br />A读 ← B写(✘)<br />A写 → B读(✘) | **A 写触发 `SIGPIPE`**                                       | **A 端**：`POLLHUP` 或 `POLLERR`（条件事件，无需注册）       |
|            |                                          |                                                |                                                              |                                                              |
| **Socket** | 本端关闭读端（**A 关闭读端**）           | `A读(✘) ← B写`（即 B 写 → A 读，A 读端关闭）   | **B 写触发 `SIGPIPE`**（对称于对端关闭读端）                 | **B 写端**：无直接 `poll` 事件，写后可能触发 `POLLERR`       |
| **Socket** | 本端关闭写端（**A 关闭写端**）（半关闭） | `A写(✘) → B读`                                 | B 写不受影响（除非 A 也关闭读端）<br />A 写端已关，若 A 再写则触发 `SIGPIPE`（对称于对端关闭写端） | **B 读端**：若注册 `POLLRDHUP`，则触发 `POLLRDHUP`；否则只触发 `POLLIN`（可读且 `read` 返回 0） |

**说明**：

- `POLLHUP` 是条件事件：即使未在 `events` 中注册，只要**描述符处于挂起状态**（如**管道读端关闭**或 **Socket 完全断开**），`revents` 中就会包含它。
- `POLLRDHUP` 需要显式注册，仅适用于 Socket，表示**对端关闭了写通道**（本端读通道关闭）。
- 管道不支持 `POLLRDHUP`，即使注册也无效。

## 4. 为什么需要 `SIGPIPE`？

- 避免进程无限阻塞：若对端读端已关闭，`write()` 将永远无法成功，可能导致进程卡死。
- 防止内核缓冲区堆积无效数据，浪费系统资源。
- 提供主动错误通知，让进程及时感知连接失效。

## 5. 处理 `SIGPIPE` 的常见方式

默认行为终止进程，在网络编程中通常需要更优雅的处理：

### 	5.1 忽略或捕获信号

```c
#include <signal.h>
signal(SIGPIPE, SIG_IGN);   // 忽略信号
```

或自定义处理函数，信号被忽略或捕获后，`write()`/`send()` 会返回 -1 并设置 `errno` 为 `EPIPE`（Broken pipe）。

### 	5.2 使用 `MSG_NOSIGNAL` 标志（`Linux`）

```c
ssize_t ret = send(sockfd, buf, len, MSG_NOSIGNAL);
if (ret == -1 && errno == EPIPE) {
    // 连接已断开
}
```

### 	5.3 使用 `SO_NOSIGPIPE` 选项（`macOS` 等）

在 socket 上设置该选项，使写操作不产生 `SIGPIPE`。

## 6. 注意事项

### 	6.1. 为什么 `POLLRDHUP` 不适用于管道？

- **设计定位**：`POLLRDHUP` 是专门为 socket 引入的，对应 TCP 协议层面的 FIN 包。管道是基于文件系统的简单流，没有半关闭概念，因此内核不会为管道产生 `POLLRDHUP` 事件。
- **即使注册也会被忽略**：在管道文件描述符上注册 `POLLRDHUP` 是无效的，`poll` 永远不会在 `revents` 中返回它。

### 	6.2. 关于显式注册

- **`POLLHUP`（poll）和 `EPOLLHUP`（`epoll`）属于“条件事件”**
  即使你在 `events` 中没有显式设置它们（例如只注册了 `POLLIN`），当条件满足时（如管道的读端关闭），`revents` 中依然会包含 `POLLHUP`（或 `EPOLLHUP`）。这是由内核自动检测并报告的。
  - **原因**：`POLLHUP` 表示文件描述符发生了“挂起”，这种状态对程序至关重要（例如管道破裂后写入会失败），因此内核总是会通知应用程序，无论你是否主动要求监听。

- **`POLLRDHUP`（poll）和 `EPOLLRDHUP`（`epoll`）需要显式注册**
  你必须在 `events` 中明确包含 `POLLRDHUP` 或 `EPOLLRDHUP`，内核才会在对方关闭写端（发送 FIN）时通知你。如果不注册，即使发生了该事件，`revents` 中也不会出现这些标志，你只能通过读取返回 0 来间接发现。
  - **仅适用于 socket**
    这些事件是 Linux 为 socket 引入的扩展，用于精确表示 TCP 的半关闭状态（对端关闭写端，即本端读通道关闭）。管道或其他文件类型不支持此事件，即使注册了也会被忽略


| 事件                       | 是否需要显式注册       | 适用对象                | 语义                                                |
| :------------------------- | :--------------------- | :---------------------- | :-------------------------------------------------- |
| `POLLHUP` / `EPOLLHUP`     | **不需要**（条件事件） | 通用（管道、socket 等） | 连接挂起（如**管道读端关闭**、**socket 完全断开**） |
| `POLLRDHUP` / `EPOLLRDHUP` | **必须显式注册**       | 仅 socket               | 仅表示另一端 关闭了写端                             |

- **socket 完全断开**：当双方都关闭写端（或收到 `RST`）时，连接彻底失效，此时触发 `POLLHUP`，而不是 `POLLRDHUP`。

# 10.5.3 `SIGURG`

在Linux环境下，内核通知应用程序带外数据到达主要有两种方法：

- 一种是第9章介绍的I/O复用技术，`select`等系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件==参见代码清单9-1==
- 使用`SIGURG`信号==参见代码清单10-3==

> 代码清单10-3 用`SIGURG`检测带外数据是否到达

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <fcntl.h>
#include <libgen.h>

#define BUF_SIZE 1024

static int connfd;
//SIGURG信号的处理函数
void sig_urg(int sig)
{
    ubt save_errno = errno;
    char buffer[BUF_SIZE];
    memset(buffer,'\0',BUF_SIZE);
    int ret = recv(connfd,buffer,BUF_SIZE-1,MSG_OOB);//接受带外数据
    printf("got %d bytes of oob data '%s'\n",ret,buffer);
    errno = save_errno;
}

//设置信号处理函数
void addsig(int sig)
{
    struct sigaction sa;
    memset(&sa,'\0',sizeof(sa));
    sa.sa_handler = sig_handler;//注册信号处理函数
    sa.sa_flags |= SA_RESTART;//自动重启被信号中断的系统调用
    sigfillset(&sa.sa_mask);//执行处理函数时，阻塞所有信号
    assert(sigaction(sig,&sa,NULL) != -1);
}

int main(int argc,,char* argv[])
{
    if(argc <= 2)
    {
        printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return -1;
    }
    const char* ip = argv[1];
    int port = atoi(argv[2]);

    struct sockaddr_in address;
    bzero(&address,sizeof(address));
    address.sin_family - AF_INET;
    inet_pton(AF_INET,ip,&address.sin_addr);
    address.sin_port = htons(port);

    int sock = socket(PF_INET,SOCK_STREAM,0);
    assert(sockf>=0);

    int ret = bind(sock,(struct sockaddr*)&address,sizeof(address));
    assert(ret != -1);

    ret = listen(sock,5);
    assert(ret != -1);

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof(client);
    connfd == accept(sock,(struct sockaddr*)&client,&client_addrlength);
    if(connfd<0)
    {
        printf("errno is:%d\n",errno);
    }
    else
    {
        addsig(SIGURG,sig_urg);
        //使用SIGURG信号前，必须设置socket的宿主进程或进程组
        fcntl(connfd,__F_SETOWN,getpid());

        char buffer[BUF_SIZE];
        while(1)
        {
            memset(buffer,'\0',BUF_SIZE);
            ret = recv(connfd,buffer,BUF_SIZE-1,0);
            if(ret <= 0)
            {
                break;
            }
            printf("got %d bytes of normal data '%s'\n",ret,buffer);
        }
        
        close(connfd);
    }
    close(sock);
    return 0;
}
```

运行该程序，然后使用代码清单5-6所描述的客户端程序来往该服务器程序发送数据，以观察服务器是如何同时处理普通数据和带外数据的。

3-8节介绍了TCP带外数据的基本知识，其中探讨了TCP模块是如何发送和接收带外数据的。==参看5Linux网络编程基础API.md、50-51页==

5.8.1小节描述了如何在应用程序中使用带`MSG_OOB`标志的`send`/`recv`系统调用来发送/接收带外数据，并给出了相关代码。==参见	代码清单5-6、代码清单 5-7==

9.1.3小节和10.5.3小节分别介绍了检测带外数据是否到达的两种方法：I/O复用系统调用报告的异常事件和`SIGURG`信号  ==参见	代码清单9-1、代码清单10-3==

但应用程序检测到带外数据到达后，我们还需要进一步判断带外数据在数据流中的具体位置，才能够准确无误地读取带外数据。

5.9节介绍的`sockatmark`系统调用就是专门用于解决这个问题的。它判断一个socket是否处于带外标记，即该socket上下一个将被读取到的数据是否是带外数据。
